---
# Ansible Playbook for Candlestick Predictor Application Deployment

- name: Deploy Candlestick Predictor Application
  hosts: production
  become: yes
  gather_facts: yes
  
  vars:
    app_name: candlestick-predictor
    app_user: deploy
    app_directory: "/opt/{{ app_name }}"
    docker_compose_version: "2.21.0"
    build_version: "{{ build_version | default('latest') }}"
    backup_directory: "/opt/backups/{{ app_name }}"
    
    # Application configuration
    app_config:
      frontend:
        image: "{{ docker_registry }}/{{ app_name }}-frontend:{{ build_version }}"
        port: 3000
        replicas: 2
      backend:
        image: "{{ docker_registry }}/{{ app_name }}-backend:{{ build_version }}"
        port: 8000
        replicas: 3
      ai:
        image: "{{ docker_registry }}/{{ app_name }}-ai:{{ build_version }}"
        port: 8001
        replicas: 2
        
    # Security configuration
    security:
      ssl_enabled: true
      ssl_cert_path: "/etc/ssl/certs/{{ app_name }}.crt"
      ssl_key_path: "/etc/ssl/private/{{ app_name }}.key"
      
    # Monitoring configuration
    monitoring:
      prometheus_port: 9090
      grafana_port: 3001
      alertmanager_port: 9093
  
  pre_tasks:
    - name: Check if deployment user exists
      user:
        name: "{{ app_user }}"
        state: present
        shell: /bin/bash
        createhome: yes
      
    - name: Create application directory
      file:
        path: "{{ app_directory }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'
        
    - name: Create backup directory
      file:
        path: "{{ backup_directory }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'

  tasks:
    - name: Update system packages
      apt:
        update_cache: yes
        upgrade: dist
        autoremove: yes
        autoclean: yes
      
    - name: Install required packages
      apt:
        name:
          - docker.io
          - docker-compose
          - nginx
          - ufw
          - fail2ban
          - htop
          - curl
          - wget
          - git
          - unzip
        state: present
        
    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes
        
    - name: Add deploy user to docker group
      user:
        name: "{{ app_user }}"
        groups: docker
        append: yes
        
    - name: Configure UFW firewall
      ufw:
        rule: "{{ item.rule }}"
        port: "{{ item.port }}"
        proto: "{{ item.proto | default('tcp') }}"
      loop:
        - { rule: 'allow', port: '22', proto: 'tcp' }
        - { rule: 'allow', port: '80', proto: 'tcp' }
        - { rule: 'allow', port: '443', proto: 'tcp' }
        - { rule: 'allow', port: '3000', proto: 'tcp' }
        - { rule: 'deny', port: '8000', proto: 'tcp' }  # Backend - internal only
        - { rule: 'deny', port: '8001', proto: 'tcp' }  # AI service - internal only
      notify: restart ufw
      
    - name: Enable UFW
      ufw:
        state: enabled
        policy: deny
        
    - name: Create backup of current deployment
      shell: |
        if [ -d "{{ app_directory }}/current" ]; then
          tar -czf "{{ backup_directory }}/backup-$(date +%Y%m%d-%H%M%S).tar.gz" \
            -C "{{ app_directory }}" current/
        fi
      become_user: "{{ app_user }}"
      
    - name: Download docker-compose binary
      get_url:
        url: "https://github.com/docker/compose/releases/download/v{{ docker_compose_version }}/docker-compose-Linux-x86_64"
        dest: /usr/local/bin/docker-compose
        mode: '0755'
        
    - name: Copy application configuration files
      template:
        src: "{{ item.src }}"
        dest: "{{ app_directory }}/{{ item.dest }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'
      loop:
        - { src: 'docker-compose.prod.yml.j2', dest: 'docker-compose.yml' }
        - { src: 'nginx.conf.j2', dest: 'nginx.conf' }
        - { src: '.env.prod.j2', dest: '.env' }
      
    - name: Copy SSL certificates
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        owner: root
        group: root
        mode: '0600'
      loop:
        - { src: 'ssl/{{ app_name }}.crt', dest: '{{ security.ssl_cert_path }}' }
        - { src: 'ssl/{{ app_name }}.key', dest: '{{ security.ssl_key_path }}' }
      when: security.ssl_enabled
      
    - name: Login to Docker registry
      docker_login:
        registry_url: "{{ docker_registry }}"
        username: "{{ docker_registry_username }}"
        password: "{{ docker_registry_password }}"
      become_user: "{{ app_user }}"
      
    - name: Pull Docker images
      docker_image:
        name: "{{ item }}"
        source: pull
        force_source: yes
      loop:
        - "{{ app_config.frontend.image }}"
        - "{{ app_config.backend.image }}"
        - "{{ app_config.ai.image }}"
      become_user: "{{ app_user }}"
      
    - name: Stop existing services
      docker_compose:
        project_src: "{{ app_directory }}"
        state: absent
      become_user: "{{ app_user }}"
      ignore_errors: yes
      
    - name: Start application services
      docker_compose:
        project_src: "{{ app_directory }}"
        state: present
        pull: yes
      become_user: "{{ app_user }}"
      register: docker_compose_result
      
    - name: Wait for services to be ready
      uri:
        url: "{{ item.url }}"
        method: GET
        status_code: 200
      loop:
        - { url: 'http://localhost:8000/health', service: 'backend' }
        - { url: 'http://localhost:8001/health', service: 'ai' }
        - { url: 'http://localhost:3000', service: 'frontend' }
      retries: 30
      delay: 10
      
    - name: Configure nginx reverse proxy
      template:
        src: nginx-site.conf.j2
        dest: /etc/nginx/sites-available/{{ app_name }}
        owner: root
        group: root
        mode: '0644'
      notify: restart nginx
      
    - name: Enable nginx site
      file:
        src: /etc/nginx/sites-available/{{ app_name }}
        dest: /etc/nginx/sites-enabled/{{ app_name }}
        state: link
      notify: restart nginx
      
    - name: Remove default nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: restart nginx
      
    - name: Test nginx configuration
      command: nginx -t
      register: nginx_test
      changed_when: false
      
    - name: Configure log rotation
      template:
        src: logrotate.conf.j2
        dest: /etc/logrotate.d/{{ app_name }}
        owner: root
        group: root
        mode: '0644'
        
    - name: Setup monitoring with Prometheus
      docker_container:
        name: prometheus
        image: prom/prometheus:latest
        ports:
          - "{{ monitoring.prometheus_port }}:9090"
        volumes:
          - "{{ app_directory }}/monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro"
          - "prometheus_data:/prometheus"
        restart_policy: unless-stopped
        networks:
          - name: "{{ app_name }}_network"
        command:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus'
          - '--web.console.libraries=/etc/prometheus/console_libraries'
          - '--web.console.templates=/etc/prometheus/consoles'
          - '--storage.tsdb.retention.time=200h'
          - '--web.enable-lifecycle'
      become_user: "{{ app_user }}"
      when: monitoring_enabled | default(false)
      
    - name: Setup Grafana
      docker_container:
        name: grafana
        image: grafana/grafana:latest
        ports:
          - "{{ monitoring.grafana_port }}:3000"
        environment:
          GF_SECURITY_ADMIN_PASSWORD: "{{ grafana_admin_password }}"
        volumes:
          - "grafana_data:/var/lib/grafana"
        restart_policy: unless-stopped
        networks:
          - name: "{{ app_name }}_network"
      become_user: "{{ app_user }}"
      when: monitoring_enabled | default(false)
      
    - name: Create systemd service for application
      template:
        src: systemd-service.j2
        dest: /etc/systemd/system/{{ app_name }}.service
        owner: root
        group: root
        mode: '0644'
      notify:
        - reload systemd
        - restart app service
        
    - name: Enable and start application service
      systemd:
        name: "{{ app_name }}"
        enabled: yes
        state: started
        daemon_reload: yes
        
    - name: Setup health check cron job
      cron:
        name: "{{ app_name }} health check"
        minute: "*/5"
        job: "/opt/scripts/health-check.sh {{ app_name }}"
        user: "{{ app_user }}"
        
    - name: Clean up old Docker images
      shell: |
        docker image prune -f
        docker system prune -f
      become_user: "{{ app_user }}"
      
    - name: Clean up old backups (keep last 10)
      shell: |
        cd {{ backup_directory }}
        ls -t backup-*.tar.gz | tail -n +11 | xargs -r rm
      become_user: "{{ app_user }}"
      
  handlers:
    - name: restart nginx
      systemd:
        name: nginx
        state: restarted
        
    - name: restart ufw
      systemd:
        name: ufw
        state: restarted
        
    - name: reload systemd
      systemd:
        daemon_reload: yes
        
    - name: restart app service
      systemd:
        name: "{{ app_name }}"
        state: restarted
        
  post_tasks:
    - name: Verify deployment
      uri:
        url: "http://localhost:3000"
        method: GET
        status_code: 200
      register: health_check
      
    - name: Send deployment notification
      mail:
        to: "{{ notification_email }}"
        subject: "{{ app_name }} Deployment Completed"
        body: |
          Deployment of {{ app_name }} version {{ build_version }} completed successfully.
          
          Deployment Details:
          - Version: {{ build_version }}
          - Host: {{ inventory_hostname }}
          - Timestamp: {{ ansible_date_time.iso8601 }}
          - Services Status: {{ docker_compose_result.services | default('N/A') }}
          
          Health Check: {{ 'PASSED' if health_check.status == 200 else 'FAILED' }}
      when: notification_email is defined